<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript">
			var canvas;
			var gl;
			var requestAnimFrame;

			var shaderProgram;
			var vertexBuffer;

			var timeStart = 0.0;
			var time = 0.0;
			var timeDelta = 0.0;
		
			// data stuff:
			function dataLoaded()
			{
				var vertices = [];//-1.0, -1.0, 0.0, 0.0, 1.0, 0.0, 1.0, -1.0, 0.0];
				//var step = 2.0 / (8.0 * 8.0 * 8.0);
				for (var i = 0; i < 8 * 8 * 8; i++)
				{
					/*var l = i * step - 1.0;
					var r = l + step;
					var t = Math.sin(data[i] / 10000);*/
				
					/*vertices[i * 18 + 0] = l;
					vertices[i * 18 + 1] = -1.0;
					vertices[i * 18 + 2] = 0.0;*/
					
					vertices[i * 3 + 0] = i;
					vertices[i * 3 + 1] = data[i];
					vertices[i * 3 + 2] = 0.0;
					
					/*vertices[i * 18 + 6] = r;
					vertices[i * 18 + 7] = -1.0;
					vertices[i * 18 + 8] = 0.0;
					
					vertices[i * 18 + 9] = r;
					vertices[i * 18 + 10] = -1.0;
					vertices[i * 18 + 11] = 0.0;
					
					vertices[i * 18 + 12] = l;
					vertices[i * 18 + 13] = t;
					vertices[i * 18 + 14] = 0.0;
					
					vertices[i * 18 + 15] = r;
					vertices[i * 18 + 16] = t;
					vertices[i * 18 + 17] = 0.0;*/
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STREAM_DRAW);
			}
			
			function loadData()
			{
				var fileref = document.createElement('script');
				fileref.setAttribute("type", "text/javascript");
				fileref.setAttribute("src", "data.json");
				fileref.onload = dataLoaded;
				if (typeof fileref!="undefined")
					document.getElementsByTagName("head")[0].appendChild(fileref);
			}

			//loadData();
			setInterval(loadData, 100);

			// WebGL stuff:
			function getShader(type, text)
			{
				var shader = gl.createShader(type);
				gl.shaderSource(shader, text);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
				{
					alert(gl.getShaderInfoLog(shader));
					return null;
				}
				return shader;
			}

			function loadProgram(vert, frag)
			{
				var vertexShader = getShader(gl.VERTEX_SHADER, vert);
				var fragmentShader = getShader(gl.FRAGMENT_SHADER, frag);
				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS))
					alert("Could not initialise shaders");
				return program;
			}

			function drawScene()
			{
				requestAnimFrame(drawScene);
	
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
				gl.useProgram(shaderProgram);
				//gl.uniform3f(shaderProgram.dataUniform, 0.0, 0.0, 0.0);
	
				gl.drawArrays(gl.POINTS, 0, /*3 * 2 **/ 8 * 8 * 8);
	
				var timeNow = new Date().getTime() * 0.001 - timeStart;
				if (time != 0)
					timeDelta = timeNow - time;
				time = timeNow;
			}

			function resize()
			{
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			}

			function showdata()
			{
				requestAnimFrame = (function()
				{
					return window.requestAnimationFrame ||
						window.webkitRequestAnimationFrame ||
						window.mozRequestAnimationFrame ||
						window.oRequestAnimationFrame ||
						window.msRequestAnimationFrame ||
						function(callback, element)
						{
							window.setTimeout(callback, 1000/60);
						};
				})();

				canvas = document.getElementById("datacanvas");
				//canvas.onresize = resize;
	
				var names = [ "webgl", "experimental-webgl", "moz-webgl", "webkit-3d" ];
				for (var i = 0; i < names.length; i++)
				{
					try
					{ 
						gl = canvas.getContext(names[i]);
						if (gl) break;
					}
					catch (e) { }
				}
				if (!gl)
					alert("Could not initialise WebGL");
		
				var vs = "attribute vec3 position;\n" +
					"const mat4 p = mat4(\n" +
						"1.0, 0, 0, 0,\n" +
						"0, 1.0, 0, 0,\n" +
						"0, 0, -10.01/9.99, -1,\n" +
						"0, 0, -2.0*10.0*0.01/9.99, 1);\n" +
					"varying mediump vec4 color;\n" +
					"void main()\n" +
					"{\n" +
						"gl_PointSize = clamp(2.0 + 16.0 * position.y * 0.00003, 0.0, 64.0);\n" +
						"color = vec4(fract(position.x * vec3(1.0 / 512.0, 1.0 / 64.0, 1.0 / 8.0)), 1.0);\n" +
						"gl_Position = p * vec4(2.0 * fract(position.x * vec3(1.0 / 512.0, 1.0 / 64.0, 1.0 / 8.0)) - vec3(1.0, 1.0, 1.8), 1.0);\n" +
					"}\n";
				var fs = "varying mediump vec4 color;\n" +
					"void main()\n" +
					"{\n" +
						"gl_FragColor = color;\n" +
					"}\n";
				shaderProgram = loadProgram(vs, fs);
				shaderProgram.positionAttribute = gl.getAttribLocation(shaderProgram, "position");
				shaderProgram.dataUniform = gl.getUniformLocation(shaderProgram, "data");
				
				vertexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				data = [0.0, 0.0, 0.0];
				dataLoaded();
				gl.enableVertexAttribArray(shaderProgram.positionAttribute);
				gl.vertexAttribPointer(shaderProgram.positionAttribute, 3, gl.FLOAT, false, 0, 0);

				gl.clearColor(0.9, 0.9, 0.9, 1.0);
				gl.enable(gl.DEPTH_TEST);
				//gl.enable(gl.CULL_FACE);
				//gl.cullFace(gl.BACK);
	
				timeStart = new Date().getTime() * 0.001;
				resize();
				drawScene();
			}
		</script>
	</head>
	<body onload="showdata();">
		<canvas id="datacanvas" width="512" height="512" style="border: none;"></canvas>
	</body>
</html>
