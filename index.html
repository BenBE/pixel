<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript">
			var canvas;
			var gl;
			var requestAnimFrame;

			var shaderProgram;
			var vertexBuffer;

			var timeStart = 0.0;
			var time = 0.0;
			var timeDelta = 0.0;
		
			// data stuff:
			function dataLoaded()
			{
				var vertices = [];
				for (var i = 0; i < 8 * 8 * 8; i++)
				{
					vertices[i * 2 + 0] = i;
					vertices[i * 2 + 1] = data[i];
				}
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STREAM_DRAW);
			}
			
			function loadData()
			{
				var fileref = document.createElement('script');
				fileref.setAttribute("type", "text/javascript");
				fileref.setAttribute("src", "data.json");
				fileref.onload = dataLoaded;
				if (typeof fileref!="undefined")
					document.getElementsByTagName("head")[0].appendChild(fileref);
			}

			//loadData();
			setInterval(loadData, 200);

			// WebGL stuff:
			function getShader(type, text)
			{
				var shader = gl.createShader(type);
				gl.shaderSource(shader, text);
				gl.compileShader(shader);
				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
				{
					alert(gl.getShaderInfoLog(shader));
					return null;
				}
				return shader;
			}

			function loadProgram(vert, frag)
			{
				var vertexShader = getShader(gl.VERTEX_SHADER, vert);
				var fragmentShader = getShader(gl.FRAGMENT_SHADER, frag);
				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				if (!gl.getProgramParameter(program, gl.LINK_STATUS))
					alert("Could not initialise shaders");
				return program;
			}

			function drawScene()
			{
				requestAnimFrame(drawScene);

				var g = 0.1 + 0.1 * Math.sin(0.73 * time);
				gl.clearColor(g, g, g, 1.0);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				gl.useProgram(shaderProgram);
				gl.uniform1f(shaderProgram.tUniform, time);
				gl.drawArrays(gl.POINTS, 0, 8 * 8 * 8);
	
				var timeNow = new Date().getTime() * 0.001 - timeStart;
				if (time != 0)
					timeDelta = timeNow - time;
				time = timeNow;
			}

			function resize()
			{
				gl.viewportWidth = canvas.width;
				gl.viewportHeight = canvas.height;
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
			}

			function showdata()
			{
				requestAnimFrame = (function()
				{
					return window.requestAnimationFrame ||
						window.webkitRequestAnimationFrame ||
						window.mozRequestAnimationFrame ||
						window.oRequestAnimationFrame ||
						window.msRequestAnimationFrame ||
						function(callback, element)
						{
							window.setTimeout(callback, 1000/60);
						};
				})();

				canvas = document.getElementById("datacanvas");
				//canvas.onresize = resize;
	
				var names = [ "webgl", "experimental-webgl", "moz-webgl", "webkit-3d" ];
				for (var i = 0; i < names.length; i++)
				{
					try
					{ 
						gl = canvas.getContext(names[i]);
						if (gl) break;
					}
					catch (e) { }
				}
				if (!gl)
					alert("Could not initialise WebGL");
		
				var vs = "attribute vec2 data;\n" +
					"uniform float t;\n" +
					"const mat4 p = mat4(\n" +
						"1.0, 0, 0, 0,\n" +
						"0, 1.0, 0, 0,\n" +
						"0, 0, -10.01/9.99, -1,\n" +
						"0, 0, -2.0*10.0*0.01/9.99, 1);\n" +
					"varying mediump vec4 color;\n" +
					"void main()\n" +
					"{\n" +
						"color = vec4(fract(data.x * vec3(1.0 / 512.0, 1.0 / 64.0, 1.0 / 8.0)), 1.0);\n" +
						"mat4 m = mat4(cos(0.5 * t), 0.0, -sin(0.5 * t), 0.0,  0.0, 1.0, 0.0, 0.0,  sin(0.5 * t), 0.0, cos(0.5 * t), 0.0,  0.2 * sin(t * 1.4), 0.2 * sin(t * 2.3), -1.0, 1.0);\n" +
						"gl_Position = p * (m * vec4(2.0 * fract(data.x * vec3(1.0 / 512.0, 1.0 / 64.0, 1.0 / 8.0)) - vec3(1.0), 1.0));\n" +
						"float z = gl_Position.z / gl_Position.w;\n" + 
						"gl_PointSize = clamp(2.0 + 16.0 * data.y * 0.00003 - 2.0 * z, 1.0, 64.0);\n" +
					"}\n";
				var fs = "varying mediump vec4 color;\n" +
					"void main()\n" +
					"{\n" +
						"gl_FragColor = color;\n" +
					"}\n";
				shaderProgram = loadProgram(vs, fs);
				shaderProgram.dataAttribute = gl.getAttribLocation(shaderProgram, "data");
				shaderProgram.tUniform = gl.getUniformLocation(shaderProgram, "t");
				
				vertexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
				data = [];
				dataLoaded();
				gl.enableVertexAttribArray(shaderProgram.dataAttribute);
				gl.vertexAttribPointer(shaderProgram.dataAttribute, 2, gl.FLOAT, false, 0, 0);

				gl.enable(gl.DEPTH_TEST);
				//gl.enable(gl.CULL_FACE);
				//gl.cullFace(gl.BACK);

				timeStart = new Date().getTime() * 0.001;
				resize();
				drawScene();
			}
		</script>
	</head>
	<body onload="showdata();" style="background:black;color:white;font-family:monospace;">
		<h1>ohai to pixelflut!</h1>
		Real-time usage of the RGB color space quantized to eight sections on each axis:<br>
		<canvas id="datacanvas" width="512" height="512" style="border: none;"></canvas><br>
		<h2>how to flut</h2>
		Connect via TCP to this address/port and use the following commandz:
		<ul>
			<li><b>send pixel:</b> 'PX {x} {y} {GG or RRGGBB or RRGGBBAA as HEX}\n'</li>
			<li><b>request pixel:</b> 'PX {x} {y}\n'</li>
			<li><b>request resolution:</b> 'SIZE\n'</li>
			<li><b>request client connection count:</b> 'CONNECTIONS\n'</li>
			<li><b>request this help message:</b> 'HELP\n'</li>
		</ul>
	</body>
</html>
